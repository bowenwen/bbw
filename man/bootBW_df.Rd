% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootBW_df.R
\name{bootBW_df}
\alias{bootBW_df}
\title{\code{bootBW_df} : Blocked Weighted Bootstrap using dplyr sample_n() for faster sampling and flexible analysis.}
\usage{
bootBW_df(x, sw, statistic = NULL, replicates = 1000)
}
\arguments{
\item{x}{A data frame with primary sampling unit (PSU) in column named \code{psu}}

\item{sw}{A data frame with primary sampling unit (PSU) in column named \code{psu}
, survey weight (i.e. PSU population) in column named \code{pop}
, and strata (i.e. region or rate bins) with whole numbers (1,2,3...) in column named \code{strata}
Note: set pop all to 1 to disable weight, set strata all to 1 to disable strata}

\item{statistic}{A function operating on data in \code{x} (see Example)}

\item{replicates}{Number of bootstrap replicates}
}
\value{
A data frame with:
\describe{
\item{}{\code{ncol} = columns_of_summary_stat + 1_trial_column)}
\item{}{\code{nrow} = replicates * rows_of_summary_stat}
\item{}{\code{names} = corresponds_to_table_X}
}
}
\description{
The \code{blocked weighted bootstrap (BBW)} is an estimation technique for
use with data from two-stage cluster sampled surveys in which either prior
weighting (e.g. \code{population proportional sampling} or \code{PPS} as
used in \code{SMART} surveys) or posterior weighting (e.g. as used in
\code{RAM} and \code{S3M} surveys).
}
\examples{

## stratify by region
villageData$strata <- villageData$region

## define summarise function for each bootstraped sample
my_summarise <- function(df, ...) {
  df \%>\%
    filter(!is.na(wash4)) \%>\%
    group_by(mMUAC) \%>\%
    summarise(mean_wash4 = round(mean(wash4), 0))
}

## perform bootstraping
bootP_df <- bootBW_df(
  x = indicatorsHH,
  sw = villageData,
  statistic = my_summarise,
  replicates = 1000
)

## analyze result of boostrapped samples
bootP_df \%>\%
  group_by(mMUAC) \%>\%
  summarise(
    min = min(mean_wash4),
    Q25 = quantile(mean_wash4, 0.25),
    avg = mean(mean_wash4),
    Q75 = quantile(mean_wash4, 0.75),
    max = max(mean_wash4)
  )

# Note: dplyr style pipe with this function is not supported by design since there are two dataframe inputs.

}
